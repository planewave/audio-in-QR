### 项目背景与核心目标

本项目旨在实现一个纯前端的 Web 应用，能够录制短音频，将其压缩后编码为 Base64 字符串，并生成 QR 码。最终目标是让用户可以通过 iOS 快捷指令扫描该 QR 码，解码并播放音频，实现音频的离线存储与分享。

### 核心约束：QR 码数据容量

项目的根本限制在于 QR 码的数据容量。我们主要使用 Version 40-L 级别的 QR 码，其最大二进制数据容量约为 2953 字节。由于音频数据需要通过 Base64 编码（会带来约 33% 的体积膨胀），实际可用的二进制音频数据容量约为 **2215 字节**。这意味着，所有压缩后的音频数据（包括容器开销）必须严格控制在这个大小之内。

### 开发与调试历程中的主要挑战

在实现这一目标的过程中，我们遇到了多方面的技术挑战：

1.  **Web 应用基础功能调试**：
    *   **`MediaRecorder` 兼容性**：浏览器对 `audio/wav` 录制格式的支持不一致，导致 `NotSupportedError`。解决方案是移除 `mimeType` 参数，让浏览器使用默认支持的格式。
    *   **`qrcode.js` 库加载问题**：最初尝试加载 `qrcode.js` 时，遇到了 CommonJS 模块与 ES 模块混淆、`require is not defined` 等问题。最终通过切换到 `esm.sh` CDN 并使用命名空间导入 (`import * as QRCode`) 解决。
    *   **`ffmpeg.wasm` 库加载与兼容性**：这是最复杂和持久的挑战。
        *   **CDN 网络错误**：`NetworkError` 导致 `ffmpeg.js` 无法加载。尝试更换 CDN (unpkg -> jsdelivr) 未果。
        *   **顽固的浏览器缓存**：即使更换 CDN，浏览器仍尝试加载带错误 URL 的旧版本脚本。通过在 Worker URL 中添加时间戳 (`?v=...`) 强制刷新解决。
        *   **`document is not defined` 错误**：这是最根本的问题。`ffmpeg.wasm` 的 v0.12.x 版本（以及我们尝试的 v0.11.0 UMD 构建）在 Web Worker 环境中会尝试访问 `document` 对象，导致 `ReferenceError`。
        *   **最终解决方案**：放弃在 Web Worker 中处理 FFmpeg，将所有 FFmpeg 操作移至**主线程**。这虽然可能导致 UI 阻塞，但解决了根本的兼容性问题。
    *   **Base64 编码格式不匹配**：最初使用了“URL-safe”的 Base64 编码，但 iOS 快捷指令的解码器需要**标准 Base64**。修正了编码函数以输出标准 Base64。

2.  **音频时长与 QR 码容量的极限挑战**：
    *   **初始“音频过长”问题**：即使是 2.0 秒的 Opus 音频（8kbps），在默认 MP4 容器下也远超 2215 字节限制。
    *   **优化尝试 1：严格 Opus 参数**：添加 `-vbr off` 和 `-compression_level 10` 等参数，略微减小了文件，但不足以达标。
    *   **优化尝试 2：Ogg 容器**：切换到 Ogg 容器显著减小了文件体积，但导致音频无法在 iOS 快捷指令中播放（Ogg 容器不兼容）。
    *   **优化尝试 3：AAC 编码**：尝试切换到 AAC 编码（MP4 容器），希望利用其原生兼容性。但即使在 16kbps 甚至 8kbps 的极低比特率下，文件体积依然过大，无法满足容量要求。
    *   **优化尝试 4：分片 MP4 (`-movflags`)**：重新使用 Opus 编码，并加入 `-movflags frag_keyframe+empty_moov` 参数以最小化 MP4 容器开销。虽然在理论上能大幅减小体积，但生成的 MP4 文件（分片结构）**无法被 iOS 快捷指令的“播放声音”功能识别和播放**。
    *   **当前工作方案**：最终，我们回到了用户在 `README.md` 中验证过的、最基础的 FFmpeg 命令 (`-c:a libopus -b:a 8k -ac 1 -ar 8000`)。这个方案在 **~1.2 秒**的录音时长下能够稳定工作，并被 iOS 快捷指令识别。
    *   **静音裁剪功能**：为了在有限时长内最大化有效音频，我们实现了录制 1.6 秒，然后通过 FFmpeg 滤镜 (`silenceremove`, `atrim`) 自动裁剪头部静音，并将有效音频限制在 **1.15 秒**。

### **核心未解决问题：如何在有限容量下存储更长音频**

尽管我们已成功实现了一个功能完整的 MVP，但如何在不牺牲 iOS 快捷指令兼容性的前提下，存储超过 1.15 秒的有效音频，仍然是一个悬而未决的挑战。

**主要瓶颈在于：**

1.  **MP4 容器的固有开销**：即使是最优化的标准 MP4 容器，其元数据开销对于 QR 码的极小容量来说依然是巨大的负担。
2.  **iOS 快捷指令的严格兼容性**：其“播放声音”功能对音频文件格式（特别是 MP4 容器结构）的要求非常严格，无法处理非标准或高度优化的文件（如分片 MP4）。

### **未来研究方向**

为了突破当前 1.15 秒的有效音频时长限制，以下是值得进一步探索的方向：

1.  **iOS 快捷指令与 QR 码解码深度研究**：
    *   **二进制 QR 码**：能否找到或开发一种 iOS 快捷指令动作，能够扫描 QR 码并直接输出**原始二进制数据**，而不是文本？这将消除 Base64 编码带来的 33% 体积开销，使有效音频时长增加到约 **1.5 秒**。这是目前最有潜力的突破口。
    *   **第三方 QR 解码器**：是否有第三方快捷指令动作或 App 提供了更灵活的 QR 码解码能力，能够处理二进制数据？
    *   **“播放声音”动作的替代**：是否有其他 iOS 快捷指令动作或 App 能够播放更极限优化的 MP4 文件（如分片 MP4），或者能够从原始 Opus/AAC 数据流中重建并播放音频？

2.  **FFmpeg/音频编码器极限优化**：
    *   **超极限 MP4 容器**：是否存在 FFmpeg 参数组合，能够生成一个比当前更小、但仍能被 iOS 快捷指令识别的 MP4 文件？这可能需要深入研究 MP4 规范和 iOS 的解码器行为。
    *   **其他超低比特率编码器**：研究是否有其他比 Opus 更高效的、专为语音设计的编码器（如 Lyra, Codec2），并评估其在 WebAssembly 中的可行性以及 iOS 端的播放兼容性（可能需要自定义解码器）。

3.  **自定义 iOS 播放器**：
    *   如果所有快捷指令内的方案都无法实现，最终的解决方案可能是开发一个**自定义的 iOS App**。该 App 可以扫描 QR 码，获取原始二进制数据，并在 App 内部使用更强大的解码器和播放器来处理和播放音频，从而完全绕过快捷指令的限制。

希望这份报告能为后续的研究者提供清晰的指引。